<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quill Paste & Export Tests</title>
  <link href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css" rel="stylesheet">
  <link href="../styles/quill-table-better.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;500;600&family=DM+Sans:wght@400;500;600&family=Roboto:wght@400;500&family=Open+Sans:wght@400;500&family=Lato:wght@400;700&family=Montserrat:wght@400;500;600&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-pass: #22c55e;
      --color-fail: #ef4444;
      --color-pending: #f59e0b;
      --color-bg: #0f172a;
      --color-card: #1e293b;
      --color-text: #e2e8f0;
      --color-muted: #94a3b8;
      --color-border: #334155;
    }
    
    * { box-sizing: border-box; }
    
    body {
      font-family: 'SF Mono', 'Fira Code', 'Monaco', monospace;
      background: var(--color-bg);
      color: var(--color-text);
      margin: 0;
      padding: 24px;
      line-height: 1.6;
    }
    
    h1 {
      font-size: 24px;
      font-weight: 600;
      margin: 0 0 8px 0;
      color: white;
    }
    
    .subtitle {
      color: var(--color-muted);
      margin-bottom: 24px;
      font-size: 14px;
    }
    
    .summary {
      display: flex;
      gap: 24px;
      margin-bottom: 24px;
      padding: 16px;
      background: var(--color-card);
      border-radius: 8px;
      border: 1px solid var(--color-border);
    }
    
    .summary-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .summary-count {
      font-size: 24px;
      font-weight: 700;
    }
    
    .summary-label {
      font-size: 12px;
      color: var(--color-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .pass { color: var(--color-pass); }
    .fail { color: var(--color-fail); }
    .pending { color: var(--color-pending); }
    
    .test-group {
      background: var(--color-card);
      border-radius: 8px;
      border: 1px solid var(--color-border);
      margin-bottom: 16px;
      overflow: hidden;
    }
    
    .test-group-header {
      padding: 12px 16px;
      background: rgba(0,0,0,0.2);
      border-bottom: 1px solid var(--color-border);
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .test-case {
      padding: 12px 16px;
      border-bottom: 1px solid var(--color-border);
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    
    .test-case:last-child { border-bottom: none; }
    
    .test-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      font-size: 12px;
    }
    
    .test-icon.pass { background: rgba(34, 197, 94, 0.2); }
    .test-icon.fail { background: rgba(239, 68, 68, 0.2); }
    
    .test-content { flex: 1; }
    .test-name { font-weight: 500; margin-bottom: 4px; }
    .test-details { font-size: 12px; color: var(--color-muted); }
    
    .test-error {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 4px;
      padding: 8px 12px;
      margin-top: 8px;
      font-size: 12px;
      color: var(--color-fail);
    }
    
    .code-block {
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
      padding: 8px 12px;
      margin-top: 8px;
      font-size: 11px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 200px;
      overflow-y: auto;
    }
    
    .code-label {
      font-size: 10px;
      color: var(--color-muted);
      text-transform: uppercase;
      margin-bottom: 4px;
    }
    
    #test-editor-container {
      position: absolute;
      left: -9999px;
      top: -9999px;
      width: 800px;
      height: 600px;
    }
    
    .run-btn {
      background: linear-gradient(135deg, #3b82f6, #8b5cf6);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-family: inherit;
      margin-bottom: 24px;
      margin-right: 8px;
    }
    
    .run-btn:hover { opacity: 0.9; }
    .run-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Font family classes for testing */
    .ql-font-roboto { font-family: 'Roboto', sans-serif; }
    .ql-font-open-sans { font-family: 'Open Sans', sans-serif; }
    .ql-font-lato { font-family: 'Lato', sans-serif; }
    .ql-font-montserrat { font-family: 'Montserrat', sans-serif; }
    .ql-font-source-code { font-family: 'Source Code Pro', monospace; }
    .ql-font-crimson { font-family: 'Crimson Pro', serif; }
    .ql-font-dm-sans { font-family: 'DM Sans', sans-serif; }
    
    .ql-size-small { font-size: 0.75em; }
    .ql-size-large { font-size: 1.5em; }
    .ql-size-huge { font-size: 2.5em; }
  </style>
</head>
<body>
  <h1>üß™ Quill Paste & Export Tests</h1>
  <p class="subtitle">Testing paste preservation and export functionality for fonts, tables, and formatting</p>
  
  <button class="run-btn" id="runTests">‚ñ∂ Run All Tests</button>
  <button class="run-btn" id="runPasteTests" style="background: linear-gradient(135deg, #10b981, #059669);">üìã Paste Tests</button>
  <button class="run-btn" id="runExportTests" style="background: linear-gradient(135deg, #f59e0b, #d97706);">üì§ Export Tests</button>
  
  <div class="summary" id="summary">
    <div class="summary-item">
      <span class="summary-count pass" id="passCount">0</span>
      <span class="summary-label">Passed</span>
    </div>
    <div class="summary-item">
      <span class="summary-count fail" id="failCount">0</span>
      <span class="summary-label">Failed</span>
    </div>
    <div class="summary-item">
      <span class="summary-count" id="totalCount">0</span>
      <span class="summary-label">Total</span>
    </div>
  </div>
  
  <div id="results"></div>
  
  <!-- Hidden editor for testing -->
  <div id="test-editor-container">
    <div id="test-editor"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.js"></script>
  <!-- Disabled: quill-table-better crashes on load in standalone test environment -->
  <!-- <script src="../js/quill-table-better.js"></script> -->
  <script>
    // ============================================
    // Test Framework Setup
    // ============================================
    const results = { passed: 0, failed: 0, tests: [] };
    let editor;
    const Delta = Quill.import('delta');
    
    // Font mapping (mirrors quill_editor.html)
    const fontFamilyMap = {
      'roboto': 'roboto',
      'open sans': 'open-sans',
      'lato': 'lato',
      'montserrat': 'montserrat',
      'source code pro': 'source-code',
      'crimson pro': 'crimson',
      'dm sans': 'dm-sans',
      'arial': 'roboto',
      'helvetica': 'roboto',
      'georgia': 'crimson',
      'times new roman': 'crimson',
      'courier new': 'source-code'
    };
    
    // Map font family to Quill font
    function mapFontFamily(fontFamily) {
      if (!fontFamily) return false;
      const fonts = fontFamily.toLowerCase().split(',').map(f => f.trim().replace(/['"]/g, ''));
      for (const font of fonts) {
        if (fontFamilyMap[font]) return fontFamilyMap[font];
        for (const [key, value] of Object.entries(fontFamilyMap)) {
          if (font.includes(key) || key.includes(font)) return value;
        }
      }
      return false;
    }
    
    // Map font sizes
    function mapFontSize(size) {
      if (!size) return false;
      const sizeStr = size.toLowerCase().trim();
      let pxValue = null;
      
      if (sizeStr.endsWith('px')) pxValue = parseFloat(sizeStr);
      else if (sizeStr.endsWith('pt')) pxValue = parseFloat(sizeStr) * 1.333;
      else if (sizeStr.endsWith('em')) pxValue = parseFloat(sizeStr) * 16;
      
      if (sizeStr === 'small' || sizeStr === 'x-small') return 'small';
      if (sizeStr === 'large' || sizeStr === 'x-large') return 'large';
      if (sizeStr === 'xx-large' || sizeStr === 'xxx-large') return 'huge';
      
      if (pxValue !== null) {
        if (pxValue <= 12) return 'small';
        if (pxValue <= 18) return false;
        if (pxValue <= 24) return 'large';
        return 'huge';
      }
      return false;
    }
    
    // Normalize color to hex
    function normalizeColor(color) {
      if (!color) return null;
      color = color.trim();
      if (color.startsWith('#')) return color;
      
      const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (match) {
        const r = parseInt(match[1]).toString(16).padStart(2, '0');
        const g = parseInt(match[2]).toString(16).padStart(2, '0');
        const b = parseInt(match[3]).toString(16).padStart(2, '0');
        return '#' + r + g + b;
      }
      return color;
    }
    
    // Preprocess HTML for paste (mirrors quill_editor.html logic)
    function preprocessHtml(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString('<div>' + html + '</div>', 'text/html');
      const container = doc.body.firstChild;
      
      container.querySelectorAll('*').forEach(el => {
        const style = el.style;
        const classes = [];
        
        if (style.fontFamily) {
          const font = mapFontFamily(style.fontFamily);
          if (font) {
            classes.push('ql-font-' + font);
            style.removeProperty('font-family');
          }
        }
        
        if (style.fontSize) {
          const size = mapFontSize(style.fontSize);
          if (size) {
            classes.push('ql-size-' + size);
            style.removeProperty('font-size');
          }
        }
        
        // Handle color - need to use setAttribute to preserve hex format
        if (style.color) {
          const normalizedColor = normalizeColor(style.color);
          if (normalizedColor) {
            // Remove from style object and set via attribute to preserve hex
            const otherStyles = el.getAttribute('style') || '';
            const newStyles = otherStyles
              .split(';')
              .filter(s => !s.trim().toLowerCase().startsWith('color'))
              .concat(['color: ' + normalizedColor])
              .filter(s => s.trim())
              .join('; ');
            el.setAttribute('style', newStyles);
          }
        }
        
        // Handle background color - need to use setAttribute to preserve hex format
        if (style.backgroundColor) {
          const normalizedBg = normalizeColor(style.backgroundColor);
          if (normalizedBg) {
            const otherStyles = el.getAttribute('style') || '';
            const newStyles = otherStyles
              .split(';')
              .filter(s => !s.trim().toLowerCase().startsWith('background-color') && !s.trim().toLowerCase().startsWith('background'))
              .concat(['background-color: ' + normalizedBg])
              .filter(s => s.trim())
              .join('; ');
            el.setAttribute('style', newStyles);
          }
        }
        
        if (classes.length > 0) {
          el.className = (el.className ? el.className + ' ' : '') + classes.join(' ');
        }
      });
      
      // Handle <font> tags
      container.querySelectorAll('font').forEach(font => {
        const span = doc.createElement('span');
        span.innerHTML = font.innerHTML;
        
        // Use getAttribute for font tag attributes
        const fontColor = font.getAttribute('color');
        if (fontColor) {
          const normalizedColor = normalizeColor(fontColor);
          if (normalizedColor) {
            span.setAttribute('style', 'color: ' + normalizedColor);
          }
        }
        
        const fontFace = font.getAttribute('face');
        if (fontFace) {
          const mappedFont = mapFontFamily(fontFace);
          if (mappedFont) span.classList.add('ql-font-' + mappedFont);
        }
        
        const fontSize = font.getAttribute('size');
        if (fontSize) {
          const size = parseInt(fontSize);
          if (size <= 2) span.classList.add('ql-size-small');
          else if (size >= 5) span.classList.add('ql-size-large');
          else if (size >= 6) span.classList.add('ql-size-huge');
        }
        
        font.parentNode.replaceChild(span, font);
      });
      
      return container.innerHTML;
    }
    
    // HTML Export Generator (mirrors home_page.dart)
    function generateExportHtml(editorContent) {
      return `<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="https://cdn.jsdelivr.net/npm/quill@2/dist/quill.snow.css" rel="stylesheet">
  <link href="../styles/quill-table-better.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;500;600&family=DM+Sans:wght@400;500;600&family=Roboto:wght@400;500&family=Open+Sans:wght@400;500&family=Lato:wght@400;700&family=Montserrat:wght@400;500;600&family=Source+Code+Pro:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    body { 
      font-family: 'Crimson Pro', Georgia, serif; 
      font-size: 1.125rem;
      line-height: 1.8;
      color: #2c2825;
      background: #ffffff;
      padding: 0;
      margin: 0;
    }
    
    .ql-editor { 
      padding: 24px;
      max-width: 100%;
    }
    
    /* Typography */
    .ql-editor h1 { font-size: 2.25rem; font-weight: 600; margin-bottom: 0.5em; }
    .ql-editor h2 { font-size: 1.75rem; font-weight: 600; margin-bottom: 0.5em; }
    .ql-editor h3 { font-size: 1.375rem; font-weight: 600; margin-bottom: 0.5em; }
    .ql-editor h4 { font-size: 1.125rem; font-weight: 600; margin-bottom: 0.5em; }
    .ql-editor h5 { font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5em; }
    .ql-editor h6 { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.5em; }
    .ql-editor p { margin-bottom: 1em; }
    .ql-editor blockquote { border-left: 4px solid #c45d35; padding-left: 16px; margin: 24px 0; color: #6b6560; font-style: italic; }
    .ql-editor pre { background: #f8f6f3; border-radius: 8px; padding: 16px; font-family: 'Source Code Pro', monospace; font-size: 0.875rem; overflow-x: auto; }
    .ql-editor a { color: #c45d35; text-decoration: underline; }
    .ql-editor code { background: #f0f0f0; padding: 2px 4px; border-radius: 3px; font-family: 'Source Code Pro', monospace; }
    
    /* Font family classes */
    .ql-font-roboto { font-family: 'Roboto', sans-serif; }
    .ql-font-open-sans { font-family: 'Open Sans', sans-serif; }
    .ql-font-lato { font-family: 'Lato', sans-serif; }
    .ql-font-montserrat { font-family: 'Montserrat', sans-serif; }
    .ql-font-source-code { font-family: 'Source Code Pro', monospace; }
    .ql-font-crimson { font-family: 'Crimson Pro', serif; }
    .ql-font-dm-sans { font-family: 'DM Sans', sans-serif; }
    
    /* Font size classes */
    .ql-size-small { font-size: 0.75em; }
    .ql-size-large { font-size: 1.5em; }
    .ql-size-huge { font-size: 2.5em; }
    
    /* Line height classes */
    .ql-line-height-1 { line-height: 1; }
    .ql-line-height-1-5 { line-height: 1.5; }
    .ql-line-height-2 { line-height: 2; }
    .ql-line-height-2-5 { line-height: 2.5; }
    .ql-line-height-3 { line-height: 3; }
    
    /* Text indent classes */
    .ql-indent-1 { padding-left: 3em; }
    .ql-indent-2 { padding-left: 6em; }
    .ql-indent-3 { padding-left: 9em; }
    .ql-indent-4 { padding-left: 12em; }
    .ql-indent-5 { padding-left: 15em; }
    .ql-indent-6 { padding-left: 18em; }
    .ql-indent-7 { padding-left: 21em; }
    .ql-indent-8 { padding-left: 24em; }
    
    /* Table styles */
    .ql-editor table { border-collapse: collapse; margin: 16px 0; box-sizing: border-box; }
    .ql-editor table td, .ql-editor table th { 
      border: 1px solid #e5e0da; 
      min-width: 50px;
      vertical-align: top;
    }
    .ql-editor table td:not([style*="padding"]), .ql-editor table th:not([style*="padding"]) { 
      padding: 8px 16px; 
    }
    .ql-editor table.table-with-header tr:first-child td:not([style*="background"]),
    .ql-editor table th:not([style*="background"]) { background: #f8f6f3; font-weight: 500; }
    .ql-editor table td p { margin: 0; }
    .ql-editor table colgroup, .ql-editor table col { display: table-column; }
    
    /* Table alignment */
    .ql-editor table.align-left { float: left; margin-right: 16px; margin-bottom: 8px; }
    .ql-editor table.align-center { display: table; margin-left: auto; margin-right: auto; }
    .ql-editor table.align-right { float: right; margin-left: 16px; margin-bottom: 8px; }
    
    /* List styles */
    .ql-editor ul, .ql-editor ol { padding-left: 24px; margin-bottom: 1em; }
    .ql-editor li { margin-bottom: 0.5em; }
    .ql-editor ul[data-checked="true"] > li::before { content: '‚òë'; margin-right: 8px; color: #c45d35; }
    .ql-editor ul[data-checked="false"] > li::before { content: '‚òê'; margin-right: 8px; color: #c45d35; }
    
    /* Media styles */
    .ql-editor img { max-width: 100%; border-radius: 8px; }
    .ql-editor iframe, .ql-editor video, .ql-editor .ql-video { 
      max-width: 100%; 
      display: block; 
      margin: 16px 0;
      border-radius: 8px;
    }
    
    /* Media alignment */
    .ql-editor img.align-left, .ql-editor iframe.align-left, .ql-editor video.align-left {
      float: left; margin-right: 16px; margin-bottom: 8px;
    }
    .ql-editor img.align-center, .ql-editor iframe.align-center, .ql-editor video.align-center {
      display: block; margin-left: auto; margin-right: auto; margin-top: 16px; margin-bottom: 16px;
    }
    .ql-editor img.align-right, .ql-editor iframe.align-right, .ql-editor video.align-right {
      float: right; margin-left: 16px; margin-bottom: 8px;
    }
    
    /* Text formatting */
    sub { vertical-align: sub; font-size: smaller; }
    sup { vertical-align: super; font-size: smaller; }
    .ql-direction-rtl { direction: rtl; text-align: inherit; }
    
    /* Text alignment */
    .ql-align-center { text-align: center; }
    .ql-align-right { text-align: right; }
    .ql-align-justify { text-align: justify; }
    
    /* Clear floats */
    .ql-editor::after { content: ""; display: table; clear: both; }
    .ql-editor p::after { content: ""; display: table; clear: both; }
    
    /* Hide editor artifacts */
    .ql-table-better-selected-td, .ql-table-better-selection-line, .ql-table-better-selection-block,
    .ql-table-better-col-tool, .ql-table-better-row-tool, .ql-table-better-corner,
    [class*="ql-table-better-select"], [class*="ql-table-better-tool"], temporary {
      display: none !important;
    }
  </style>
</head>
<body>
  <div class="ql-editor">${editorContent}</div>
</body>
</html>`;
    }
    
    // Initialize Quill editor
    function initEditor() {
      if (editor) return editor;
      
      try {
        // Register fonts
        const Font = Quill.import('formats/font');
        Font.whitelist = ['roboto', 'open-sans', 'lato', 'montserrat', 'source-code', 'crimson', 'dm-sans'];
        Quill.register(Font, true);
        
        // Register sizes
        const Size = Quill.import('formats/size');
        Size.whitelist = ['small', false, 'large', 'huge'];
        Quill.register(Size, true);
        
        // Try to register table-better if available
        const moduleConfig = { toolbar: false };
        if (window.QuillTableBetter) {
          try {
            Quill.register({ 'modules/table-better': window.QuillTableBetter }, true);
            moduleConfig['table-better'] = {};
          } catch (e) {
            console.warn('Could not register quill-table-better:', e);
          }
        }
        
        editor = new Quill('#test-editor', {
          theme: 'snow',
          modules: moduleConfig
        });
      } catch (e) {
        console.warn('Error initializing Quill editor:', e);
        // Create a basic editor without table-better
        editor = new Quill('#test-editor', {
          theme: 'snow',
          modules: { toolbar: false }
        });
      }
      
      return editor;
    }
    
    // ============================================
    // Test Definitions - Paste Tests
    // ============================================
    const pasteTestGroups = [
      {
        name: 'üìã Font Family Paste Preservation',
        tests: [
          {
            name: 'Should preserve Roboto font from inline style',
            run: () => {
              const inputHtml = '<span style="font-family: Roboto, sans-serif;">Roboto text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-roboto')) {
                throw new Error('Roboto font class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve Open Sans font from inline style',
            run: () => {
              const inputHtml = '<span style="font-family: \'Open Sans\', sans-serif;">Open Sans text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-open-sans')) {
                throw new Error('Open Sans font class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve Montserrat font from inline style',
            run: () => {
              const inputHtml = '<span style="font-family: Montserrat, sans-serif;">Montserrat text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-montserrat')) {
                throw new Error('Montserrat font class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve Source Code Pro font from inline style',
            run: () => {
              const inputHtml = '<span style="font-family: \'Source Code Pro\', monospace;">Code text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-source-code')) {
                throw new Error('Source Code Pro font class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve Crimson Pro font from inline style',
            run: () => {
              const inputHtml = '<span style="font-family: \'Crimson Pro\', serif;">Crimson text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-crimson')) {
                throw new Error('Crimson Pro font class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve DM Sans font from inline style',
            run: () => {
              const inputHtml = '<span style="font-family: \'DM Sans\', sans-serif;">DM Sans text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-dm-sans')) {
                throw new Error('DM Sans font class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should map Arial to Roboto',
            run: () => {
              const inputHtml = '<span style="font-family: Arial, sans-serif;">Arial text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-roboto')) {
                throw new Error('Arial not mapped to Roboto');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should map Times New Roman to Crimson',
            run: () => {
              const inputHtml = '<span style="font-family: \'Times New Roman\', serif;">Times text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-crimson')) {
                throw new Error('Times New Roman not mapped to Crimson');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve existing ql-font classes',
            run: () => {
              const inputHtml = '<span class="ql-font-lato">Lato text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-lato')) {
                throw new Error('Existing ql-font-lato class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve multiple fonts in same content',
            run: () => {
              const inputHtml = '<p><span style="font-family: Roboto;">Roboto</span> and <span style="font-family: Lato;">Lato</span></p>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-roboto') || !processed.includes('ql-font-lato')) {
                throw new Error('Multiple fonts not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          }
        ]
      },
      {
        name: 'üìè Font Size Paste Preservation',
        tests: [
          {
            name: 'Should convert small font-size (10px) to ql-size-small',
            run: () => {
              const inputHtml = '<span style="font-size: 10px;">Small text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-size-small')) {
                throw new Error('Small font size not converted');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should convert large font-size (20px) to ql-size-large',
            run: () => {
              const inputHtml = '<span style="font-size: 20px;">Large text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-size-large')) {
                throw new Error('Large font size not converted');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should convert huge font-size (30px) to ql-size-huge',
            run: () => {
              const inputHtml = '<span style="font-size: 30px;">Huge text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-size-huge')) {
                throw new Error('Huge font size not converted');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve existing ql-size classes',
            run: () => {
              const inputHtml = '<span class="ql-size-large">Large text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-size-large')) {
                throw new Error('Existing ql-size-large class not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          }
        ]
      },
      {
        name: 'üé® Color Paste Preservation',
        tests: [
          {
            name: 'Should preserve hex color',
            run: () => {
              const inputHtml = '<span style="color: #ff0000;">Red text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('#ff0000')) {
                throw new Error('Hex color not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should convert RGB to hex color',
            run: () => {
              const inputHtml = '<span style="color: rgb(255, 0, 0);">Red text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('#ff0000')) {
                throw new Error('RGB color not converted to hex');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve background color',
            run: () => {
              const inputHtml = '<span style="background-color: #ffff00;">Highlighted text</span>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('#ffff00') && !processed.includes('background')) {
                throw new Error('Background color not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should handle legacy <font> tag with color',
            run: () => {
              const inputHtml = '<font color="#0000ff">Blue text</font>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('#0000ff')) {
                throw new Error('Font tag color not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          }
        ]
      },
      {
        name: 'üìù Text Formatting Paste Preservation',
        tests: [
          {
            name: 'Should preserve bold formatting',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Bold text', attributes: { bold: true } },
                { insert: '\n' }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<strong>') && !html.includes('font-weight')) {
                throw new Error('Bold formatting not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve italic formatting',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Italic text', attributes: { italic: true } },
                { insert: '\n' }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<em>') && !html.includes('font-style')) {
                throw new Error('Italic formatting not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve underline formatting',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Underline text', attributes: { underline: true } },
                { insert: '\n' }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<u>') && !html.includes('underline')) {
                throw new Error('Underline formatting not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve strikethrough formatting',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Strike text', attributes: { strike: true } },
                { insert: '\n' }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<s>') && !html.includes('line-through')) {
                throw new Error('Strikethrough formatting not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve subscript formatting',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'H' },
                { insert: '2', attributes: { script: 'sub' } },
                { insert: 'O\n' }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<sub>')) {
                throw new Error('Subscript formatting not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve superscript formatting',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'x' },
                { insert: '2', attributes: { script: 'super' } },
                { insert: '\n' }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<sup>')) {
                throw new Error('Superscript formatting not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve combined formatting (bold + italic)',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Bold Italic', attributes: { bold: true, italic: true } },
                { insert: '\n' }
              ]);
              const html = editor.root.innerHTML;
              
              const hasBold = html.includes('<strong>') || html.includes('font-weight');
              const hasItalic = html.includes('<em>') || html.includes('font-style');
              
              if (!hasBold || !hasItalic) {
                throw new Error('Combined formatting not preserved');
              }
              return { html };
            }
          }
        ]
      },
      {
        name: 'üìä Table Paste Preservation',
        tests: [
          {
            name: 'Should preserve basic table structure',
            run: () => {
              const inputHtml = '<table><tbody><tr><td>Cell 1</td><td>Cell 2</td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('<table') || !processed.includes('<td')) {
                throw new Error('Table structure not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve table with inline border style',
            run: () => {
              const inputHtml = '<table style="border: 1px solid black;"><tbody><tr><td>Cell</td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('border')) {
                throw new Error('Table border style not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve table cell background colors',
            run: () => {
              const inputHtml = '<table><tbody><tr><td style="background-color: #f8f6f3;">Header</td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('background')) {
                throw new Error('Table cell background not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve table cell padding',
            run: () => {
              const inputHtml = '<table><tbody><tr><td style="padding: 8px 16px;">Cell</td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('padding')) {
                throw new Error('Table cell padding not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve table width',
            run: () => {
              const inputHtml = '<table style="width: 100%;"><tbody><tr><td>Cell</td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('width')) {
                throw new Error('Table width not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve formatted text inside table cells',
            run: () => {
              const inputHtml = '<table><tbody><tr><td><strong>Bold</strong> and <em>italic</em></td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('<strong>') || !processed.includes('<em>')) {
                throw new Error('Formatted text in table not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          },
          {
            name: 'Should preserve font classes inside table cells',
            run: () => {
              const inputHtml = '<table><tbody><tr><td><span class="ql-font-source-code">Code</span></td></tr></tbody></table>';
              const processed = preprocessHtml(inputHtml);
              
              if (!processed.includes('ql-font-source-code')) {
                throw new Error('Font class in table not preserved');
              }
              return { input: inputHtml, output: processed };
            }
          }
        ]
      },
      {
        name: 'üìã List Paste Preservation',
        tests: [
          {
            name: 'Should preserve bullet list',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Item 1' },
                { insert: '\n', attributes: { list: 'bullet' } },
                { insert: 'Item 2' },
                { insert: '\n', attributes: { list: 'bullet' } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<ul>') && !html.includes('data-list="bullet"')) {
                throw new Error('Bullet list not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve ordered list',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Item 1' },
                { insert: '\n', attributes: { list: 'ordered' } },
                { insert: 'Item 2' },
                { insert: '\n', attributes: { list: 'ordered' } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('<ol>') && !html.includes('data-list="ordered"')) {
                throw new Error('Ordered list not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve nested/indented lists',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Parent' },
                { insert: '\n', attributes: { list: 'bullet' } },
                { insert: 'Child' },
                { insert: '\n', attributes: { list: 'bullet', indent: 1 } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('ql-indent-1')) {
                throw new Error('Nested list indent not preserved');
              }
              return { html };
            }
          }
        ]
      },
      {
        name: '‚ÜîÔ∏è Alignment Paste Preservation',
        tests: [
          {
            name: 'Should preserve center alignment',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Centered text' },
                { insert: '\n', attributes: { align: 'center' } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('ql-align-center')) {
                throw new Error('Center alignment not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve right alignment',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Right aligned text' },
                { insert: '\n', attributes: { align: 'right' } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('ql-align-right')) {
                throw new Error('Right alignment not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve justify alignment',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'Justified text that spans multiple words' },
                { insert: '\n', attributes: { align: 'justify' } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('ql-align-justify')) {
                throw new Error('Justify alignment not preserved');
              }
              return { html };
            }
          },
          {
            name: 'Should preserve RTL direction',
            run: () => {
              initEditor();
              editor.setContents([
                { insert: 'RTL text' },
                { insert: '\n', attributes: { direction: 'rtl' } }
              ]);
              const html = editor.root.innerHTML;
              
              if (!html.includes('ql-direction-rtl')) {
                throw new Error('RTL direction not preserved');
              }
              return { html };
            }
          }
        ]
      }
    ];
    
    // ============================================
    // Test Definitions - Export Tests
    // ============================================
    const exportTestGroups = [
      {
        name: 'üì§ Export HTML Structure',
        tests: [
          {
            name: 'Should include DOCTYPE declaration',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('<!DOCTYPE html>')) {
                throw new Error('DOCTYPE declaration missing');
              }
              return { html: html.substring(0, 200) + '...' };
            }
          },
          {
            name: 'Should include UTF-8 charset meta tag',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('charset="UTF-8"')) {
                throw new Error('UTF-8 charset meta tag missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include viewport meta tag',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('viewport')) {
                throw new Error('Viewport meta tag missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include Quill CSS link',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('quill@2/dist/quill.snow.css') && !html.includes('quill.snow.css')) {
                throw new Error('Quill CSS link missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include quill-table-better CSS link',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('quill-table-better') && !html.includes('table-better.css')) {
                throw new Error('quill-table-better CSS link missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include Google Fonts link',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('fonts.googleapis.com')) {
                throw new Error('Google Fonts link missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include ql-editor wrapper div',
            run: () => {
              const html = generateExportHtml('<p>Test content</p>');
              if (!html.includes('<div class="ql-editor">')) {
                throw new Error('ql-editor wrapper div missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should preserve editor content in export',
            run: () => {
              const content = '<p>My custom content here</p>';
              const html = generateExportHtml(content);
              if (!html.includes('My custom content here')) {
                throw new Error('Editor content not preserved in export');
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: 'üî§ Export Font CSS Classes',
        tests: [
          {
            name: 'Should include .ql-font-roboto CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-roboto')) {
                throw new Error('.ql-font-roboto CSS class missing');
              }
              if (!html.includes("font-family: 'Roboto'")) {
                throw new Error('Roboto font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-font-open-sans CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-open-sans')) {
                throw new Error('.ql-font-open-sans CSS class missing');
              }
              if (!html.includes("font-family: 'Open Sans'")) {
                throw new Error('Open Sans font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-font-lato CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-lato')) {
                throw new Error('.ql-font-lato CSS class missing');
              }
              if (!html.includes("font-family: 'Lato'")) {
                throw new Error('Lato font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-font-montserrat CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-montserrat')) {
                throw new Error('.ql-font-montserrat CSS class missing');
              }
              if (!html.includes("font-family: 'Montserrat'")) {
                throw new Error('Montserrat font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-font-source-code CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-source-code')) {
                throw new Error('.ql-font-source-code CSS class missing');
              }
              if (!html.includes("font-family: 'Source Code Pro'")) {
                throw new Error('Source Code Pro font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-font-crimson CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-crimson')) {
                throw new Error('.ql-font-crimson CSS class missing');
              }
              if (!html.includes("font-family: 'Crimson Pro'")) {
                throw new Error('Crimson Pro font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-font-dm-sans CSS class',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-font-dm-sans')) {
                throw new Error('.ql-font-dm-sans CSS class missing');
              }
              if (!html.includes("font-family: 'DM Sans'")) {
                throw new Error('DM Sans font-family value missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include all 7 font families in Google Fonts link',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              const fonts = ['Crimson+Pro', 'DM+Sans', 'Roboto', 'Open+Sans', 'Lato', 'Montserrat', 'Source+Code+Pro'];
              const missing = fonts.filter(f => !html.includes(f));
              if (missing.length > 0) {
                throw new Error('Missing fonts in Google Fonts link: ' + missing.join(', '));
              }
              return { found: true, fonts };
            }
          }
        ]
      },
      {
        name: 'üìè Export Size CSS Classes',
        tests: [
          {
            name: 'Should include .ql-size-small CSS class with 0.75em',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-size-small')) {
                throw new Error('.ql-size-small CSS class missing');
              }
              if (!html.includes('font-size: 0.75em')) {
                throw new Error('Small font-size value (0.75em) missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-size-large CSS class with 1.5em',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-size-large')) {
                throw new Error('.ql-size-large CSS class missing');
              }
              if (!html.includes('font-size: 1.5em')) {
                throw new Error('Large font-size value (1.5em) missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-size-huge CSS class with 2.5em',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('.ql-size-huge')) {
                throw new Error('.ql-size-huge CSS class missing');
              }
              if (!html.includes('font-size: 2.5em')) {
                throw new Error('Huge font-size value (2.5em) missing');
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: 'üìä Export Table CSS Styles',
        tests: [
          {
            name: 'Should include table border-collapse style',
            run: () => {
              const html = generateExportHtml('<table><tr><td>Cell</td></tr></table>');
              if (!html.includes('border-collapse: collapse') && !html.includes('border-collapse:collapse')) {
                throw new Error('Table border-collapse style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include table cell border style',
            run: () => {
              const html = generateExportHtml('<table><tr><td>Cell</td></tr></table>');
              if (!html.includes('.ql-editor table td') || !html.includes('border')) {
                throw new Error('Table cell border style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include table cell padding style',
            run: () => {
              const html = generateExportHtml('<table><tr><td>Cell</td></tr></table>');
              if (!html.includes('padding: 8px 16px') && !html.includes('padding:8px 16px')) {
                throw new Error('Table cell padding style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include table header row style',
            run: () => {
              const html = generateExportHtml('<table class="table-with-header"><tr><td>Header</td></tr></table>');
              if (!html.includes('table-with-header')) {
                throw new Error('Table header class selector missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include table alignment classes',
            run: () => {
              const html = generateExportHtml('<table class="align-center"><tr><td>Cell</td></tr></table>');
              const hasLeft = html.includes('table.align-left') || html.includes('.align-left');
              const hasCenter = html.includes('table.align-center') || html.includes('.align-center');
              const hasRight = html.includes('table.align-right') || html.includes('.align-right');
              
              if (!hasLeft || !hasCenter || !hasRight) {
                throw new Error('Table alignment classes missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should hide table selection artifacts',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('ql-table-better-selected-td') || !html.includes('display: none')) {
                throw new Error('Table selection artifact hiding styles missing');
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: 'üìù Export Typography Styles',
        tests: [
          {
            name: 'Should include heading styles (h1-h6)',
            run: () => {
              const html = generateExportHtml('<h1>Title</h1>');
              const headings = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
              const missing = headings.filter(h => !html.includes(`.ql-editor ${h}`));
              if (missing.length > 0) {
                throw new Error('Missing heading styles: ' + missing.join(', '));
              }
              return { found: true };
            }
          },
          {
            name: 'Should include blockquote style with border-left',
            run: () => {
              const html = generateExportHtml('<blockquote>Quote</blockquote>');
              if (!html.includes('.ql-editor blockquote') || !html.includes('border-left')) {
                throw new Error('Blockquote style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include pre/code block style',
            run: () => {
              const html = generateExportHtml('<pre>Code</pre>');
              if (!html.includes('.ql-editor pre') || !html.includes('background')) {
                throw new Error('Pre/code block style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include link style',
            run: () => {
              const html = generateExportHtml('<a href="#">Link</a>');
              if (!html.includes('.ql-editor a')) {
                throw new Error('Link style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include inline code style',
            run: () => {
              const html = generateExportHtml('<code>inline code</code>');
              if (!html.includes('.ql-editor code')) {
                throw new Error('Inline code style missing');
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: '‚ÜîÔ∏è Export Alignment & Direction Styles',
        tests: [
          {
            name: 'Should include .ql-align-center class',
            run: () => {
              const html = generateExportHtml('<p class="ql-align-center">Centered</p>');
              if (!html.includes('.ql-align-center') || !html.includes('text-align: center')) {
                throw new Error('.ql-align-center style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-align-right class',
            run: () => {
              const html = generateExportHtml('<p class="ql-align-right">Right</p>');
              if (!html.includes('.ql-align-right') || !html.includes('text-align: right')) {
                throw new Error('.ql-align-right style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-align-justify class',
            run: () => {
              const html = generateExportHtml('<p class="ql-align-justify">Justified</p>');
              if (!html.includes('.ql-align-justify') || !html.includes('text-align: justify')) {
                throw new Error('.ql-align-justify style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include .ql-direction-rtl class',
            run: () => {
              const html = generateExportHtml('<p class="ql-direction-rtl">RTL</p>');
              if (!html.includes('.ql-direction-rtl') || !html.includes('direction: rtl')) {
                throw new Error('.ql-direction-rtl style missing');
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: 'üìã Export List Styles',
        tests: [
          {
            name: 'Should include ul/ol list styles',
            run: () => {
              const html = generateExportHtml('<ul><li>Item</li></ul>');
              if (!html.includes('.ql-editor ul') || !html.includes('.ql-editor ol')) {
                throw new Error('List styles missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include list padding-left',
            run: () => {
              const html = generateExportHtml('<ul><li>Item</li></ul>');
              if (!html.includes('padding-left')) {
                throw new Error('List padding-left missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include checklist styles',
            run: () => {
              const html = generateExportHtml('<ul data-checked="true"><li>Done</li></ul>');
              if (!html.includes('data-checked="true"') && !html.includes('data-checked="false"')) {
                throw new Error('Checklist styles missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include indent classes (ql-indent-1 through ql-indent-8)',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              const indents = [1, 2, 3, 4, 5, 6, 7, 8];
              const missing = indents.filter(i => !html.includes(`.ql-indent-${i}`));
              if (missing.length > 0) {
                throw new Error('Missing indent classes: ql-indent-' + missing.join(', ql-indent-'));
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: 'üñºÔ∏è Export Media Styles',
        tests: [
          {
            name: 'Should include image max-width style',
            run: () => {
              const html = generateExportHtml('<img src="test.jpg">');
              if (!html.includes('.ql-editor img') || !html.includes('max-width: 100%')) {
                throw new Error('Image max-width style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include iframe/video styles',
            run: () => {
              const html = generateExportHtml('<iframe src="test"></iframe>');
              if (!html.includes('.ql-editor iframe') || !html.includes('.ql-editor video')) {
                throw new Error('Iframe/video styles missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include media alignment classes',
            run: () => {
              const html = generateExportHtml('<img class="align-center" src="test.jpg">');
              const hasImageAlign = html.includes('img.align-left') || html.includes('img.align-center') || html.includes('img.align-right');
              if (!hasImageAlign) {
                throw new Error('Media alignment classes missing');
              }
              return { found: true };
            }
          }
        ]
      },
      {
        name: '‚ú® Export Text Formatting Styles',
        tests: [
          {
            name: 'Should include subscript (sub) style',
            run: () => {
              const html = generateExportHtml('<sub>2</sub>');
              if (!html.includes('sub {') || !html.includes('vertical-align: sub')) {
                throw new Error('Subscript style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include superscript (sup) style',
            run: () => {
              const html = generateExportHtml('<sup>2</sup>');
              if (!html.includes('sup {') || !html.includes('vertical-align: super')) {
                throw new Error('Superscript style missing');
              }
              return { found: true };
            }
          },
          {
            name: 'Should include clear floats style',
            run: () => {
              const html = generateExportHtml('<p>Test</p>');
              if (!html.includes('clear: both')) {
                throw new Error('Clear floats style missing');
              }
              return { found: true };
            }
          }
        ]
      }
    ];
    
    // ============================================
    // Test Runner
    // ============================================
    function runTestGroups(groups) {
      const resultsContainer = document.getElementById('results');
      resultsContainer.innerHTML = '';
      results.passed = 0;
      results.failed = 0;
      results.tests = [];
      
      initEditor();
      
      groups.forEach(group => {
        const groupEl = document.createElement('div');
        groupEl.className = 'test-group';
        
        let groupPassed = 0;
        let groupFailed = 0;
        
        const testsHtml = group.tests.map(test => {
          let status = 'pass';
          let error = null;
          let details = null;
          
          try {
            details = test.run();
            groupPassed++;
            results.passed++;
          } catch (e) {
            status = 'fail';
            error = e.message;
            groupFailed++;
            results.failed++;
          }
          
          const icon = status === 'pass' ? '‚úì' : '‚úó';
          let detailsHtml = '';
          
          if (details) {
            if (details.input && details.output) {
              detailsHtml = `
                <div class="code-block">
                  <div class="code-label">Input:</div>
                  ${escapeHtml(details.input)}
                </div>
                <div class="code-block">
                  <div class="code-label">Output:</div>
                  ${escapeHtml(details.output)}
                </div>
              `;
            } else if (details.html) {
              detailsHtml = `
                <div class="code-block">
                  <div class="code-label">Generated HTML:</div>
                  ${escapeHtml(details.html)}
                </div>
              `;
            }
          }
          
          return `
            <div class="test-case">
              <div class="test-icon ${status}">${icon}</div>
              <div class="test-content">
                <div class="test-name">${test.name}</div>
                ${error ? `<div class="test-error">${error}</div>` : ''}
                ${detailsHtml}
              </div>
            </div>
          `;
        }).join('');
        
        const statusIcon = groupFailed === 0 ? '‚úì' : '‚úó';
        const statusClass = groupFailed === 0 ? 'pass' : 'fail';
        
        groupEl.innerHTML = `
          <div class="test-group-header">
            <span class="${statusClass}">${statusIcon}</span>
            ${group.name}
            <span class="test-details">(${groupPassed}/${group.tests.length} passed)</span>
          </div>
          ${testsHtml}
        `;
        
        resultsContainer.appendChild(groupEl);
      });
      
      document.getElementById('passCount').textContent = results.passed;
      document.getElementById('failCount').textContent = results.failed;
      document.getElementById('totalCount').textContent = results.passed + results.failed;
      
      // Log results to console for automation
      console.log(`\n========== TEST RESULTS ==========`);
      console.log(`‚úÖ Passed: ${results.passed}`);
      console.log(`‚ùå Failed: ${results.failed}`);
      console.log(`üìä Total: ${results.passed + results.failed}`);
      console.log(`==================================\n`);
    }
    
    function escapeHtml(html) {
      return html
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }
    
    // Event listeners
    document.getElementById('runTests').addEventListener('click', () => {
      const btn = document.getElementById('runTests');
      btn.disabled = true;
      btn.textContent = '‚è≥ Running...';
      
      setTimeout(() => {
        runTestGroups([...pasteTestGroups, ...exportTestGroups]);
        btn.disabled = false;
        btn.textContent = '‚ñ∂ Run All Tests';
      }, 100);
    });
    
    document.getElementById('runPasteTests').addEventListener('click', () => {
      const btn = document.getElementById('runPasteTests');
      btn.disabled = true;
      btn.textContent = '‚è≥ Running...';
      
      setTimeout(() => {
        runTestGroups(pasteTestGroups);
        btn.disabled = false;
        btn.textContent = 'üìã Paste Tests';
      }, 100);
    });
    
    document.getElementById('runExportTests').addEventListener('click', () => {
      const btn = document.getElementById('runExportTests');
      btn.disabled = true;
      btn.textContent = '‚è≥ Running...';
      
      setTimeout(() => {
        runTestGroups(exportTestGroups);
        btn.disabled = false;
        btn.textContent = 'üì§ Export Tests';
      }, 100);
    });
    
    // Auto-run tests on load
    window.addEventListener('load', () => {
      setTimeout(() => runTestGroups([...pasteTestGroups, ...exportTestGroups]), 500);
    });
  </script>
</body>
</html>

